# programming_lang
## 1, HQ9Plusインタプリタの作成
## 2, brainf_ckインタプリタの作成
##目的
* rubyの練習
* 言語開発の基礎学習のため
* ユーザー定義プログラミング言語作成ベース

# brainf_ckについて
brainf_ckはチューリング完全な言語であり実際に存在する言語である。  
今回はこの言語をrubyによって実装したいと思う
###言語仕様
* brainf*ckの世界にはテープと呼ばれる配列が一つある。
* テープは十分な長さがあり、各要素は一バイトの範囲の整数、つまり０〜２５５までの値がもてる。
* テープの中身は最初すべて０の初期化が行われている。
* テープの他にポインタと呼ばれる、テープの位置を示すオブジェクトがある。
* ポインタは最初、テープの一番左の要素を指していて、命令によって左右に一ずつ動かせる。

####このような環境の元、８つの命令が定義されている。

* 命令１「>」:ポインタを右へ１移動
* 命令２「<」:ポインタを左へ１移動
* 命令３「+」:ポインタがある位置の数値を１加算
* 命令４「-」:ポインタがある位置の数値を１減算
* 命令５「.」:ポインタがある位置の数値をASCII code と見なして、その文字を出力する。
* 命令６「,」:標準入力から１文字読込、その文字のASCII code をポインタ位置に書込。
* 命令７「[」:ポインタの位置の数値が０以外なら何もしない。０なら、対応する「]」まで命令を読み飛ばし、「]」の次の命令から実行する。
* 命令８「]」:ポインタ位置の数値が０なら何もしない。０以外なら、対応する「[」まで戻り、「[」の次の命令から実行する。

の８つの定義。
これ以外の文字を使った場合無視する
そのため、自由にインデントを入れることができる。

####命令７と命令８について

* brainf*ckでは「[」と「]」が分岐いわゆるifなど、と繰り返しいわゆるwhileなどを兼ねている。
* 「[」と「]」はネストして使用可能、つまり二重や三重のループ処理も可能ということ
* ただし、「[」と「]」は必ず１対１に対応すること。

```ruby
+++[---]>---]
```

のように「]」が「[」より多かったり

```ruby
--[++[++[---]>
```

のように「[」が「]」より多いプログラムは認められない。

####移植性のための注意事項

* brainf*ckはシンプルである。
* なのでコンパイラやインタプリタなどの処理系が多く作られている。
* しかし,brainf*ckには厳密に決められた言語仕様が存在しないので、処理系によって細部の動作が微妙に異なる。
* （例）
* ポインタが一番左に位置するとき「<」命令を使用時、起こる挙動は不確定。
* ポインタ位置の数値が２５５時「+」命令を使用した時、起こる挙動は不確定。
* ポインタ位置の数値が０時「-」命令を使用した時、起こる挙動は不確定。
* などなど。

トークンについて
initializeでソースコードsrcをcharsで文字列に分割している。
Brainf*ckには「[」と「]」というジャンプ命令が存在するため、ソースコードにランダムにアクセスする必要があるゆえ。  

文字単位に分割したソースコードは、@tokensという変数に保存している。  
トークンとはソースコードを処理系が扱いやすいように分割したものをいう。  
今回のbrainf*ckは命令がたったの８つでかつ、１文字の命令のみなのでトークンに分割するには単に一文字で区切れば良い。  

##「+」「-」の実装について
まずは、インタプリタの状態を示す三つの変数が必要。  
####変数
* tape = []  
テープを表現する配列。テープの長さはrubyを使うため、メモリが許す限りの長い配列を可能にする。  
テープは全て0に初期化する必要があるが、半永久的な長さの配列を0で初期化はしない。  
つまり、テープの各位置のfirstアクセス時に0で初期化。
* pc = 0  
brainf*ckプログラムの最初から何番目の命令を実行しているかを示す変数。  
初期値は0  
基本は命令を一つ読むごとに１加算するが、「[」「]」を使った場合は値が大きく変化することもある。  
* cur = 0  
ポインタが現在どの要素を指しているかを示す変数  
初期値は0  
currentの略

###tape[cur]初期化の実装

```ruby
tape[cur] ||= 0
```
のコードで初期化している。  
"||="　は初期化されていないかもしれない変数を使うときのイデオム。 
"x|| = y"は"x = x||y"の略した記法である。
つまり、

```ruby
tape[cur] = tape[cur] || 0
```
tape[cur]が nill か false　なら,  
tape[cur]には0が代入される。  
tape[cur]にnilでもfalseでもない値が入っていた場合は、

```ruby
tape[cur] = tape[cur]
```
と同じになる。  
なので、tape[cur]の値は不変である。  
##「>」「<」の実装について
ポインタを左右に動かす「>」「<」は、変数curを1加算したり、１減算するだけなので、実装は簡単。  
注意点を一つ挙げるとしたら、ポインタがテープの左端にあるときに「<」を実行した場合、エラーにすべきとする。  

rubyでエラー報告を行うには、例外を使うのが簡単。

```ruby
raise "開始地点より左には移動できません"
```
このように、エラーメッセージを引数に取りKernel#raiseメソッドをcallすれば良い。  
(環境によっては、文字コードに応じて-Kオプションが必要)

ProgramErrorという新たな例外処理の定義

```ruby
class ProgramError < StandardError
end

raise ProgramError, "プログラムが間違っているようです"
```
により定義できる。  
またStandardErrorをcallし親クラスに選んだわけは、rescueでキャッチできるのがこのクラスのみであるから。  

参照方法  
例外ProgramErrorは「class Brainf_ck」の中で定義しているので、Brainf_ckを使う側からは、  
「Brainf_ck::ProgramError」という名前で参照できる。  

##「.」「,」の実装  
入出力を行う命令、「.」「,」の実装は以下  

```ruby
when "."
  n = (tape[cur] || 0)
  print n.chr
when ","
  tape[cur] = $stdin.getc.org
end
```


####ASCIIコード表
[Link](http://www9.plala.or.jp/sgwr-t/c_sub/ascii.html)


#### © copy write by kazuya yuda all right reserve.



