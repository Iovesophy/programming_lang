# programming_lang
## 1, HQ9Plusインタプリタの作成
## 2, brainf_ckインタプリタの作成
##目的
* rubyの練習
* 言語開発の基礎学習のため
* ユーザー定義プログラミング言語作成ベース

# brainf_ckについて
brainf_ckはチューリング完全な言語であり実際に存在する言語である。  
今回はこの言語をrubyによって実装したいと思う
###言語仕様
* brainf*ckの世界にはテープと呼ばれる配列が一つある。
* テープは十分な長さがあり、各要素は一バイトの範囲の整数、つまり０〜２５５までの値がもてる。
* テープの中身は最初すべて０の初期化が行われている。
* テープの他にポインタと呼ばれる、テープの位置を示すオブジェクトがある。
* ポインタは最初、テープの一番左の要素を指していて、命令によって左右に一ずつ動かせる。

####このような環境の元、８つの命令が定義されている。

* 命令１「>」:ポインタを右へ１移動
* 命令２「<」:ポインタを左へ１移動
* 命令３「+」:ポインタがある位置の数値を１加算
* 命令４「-」:ポインタがある位置の数値を１減算
* 命令５「.」:ポインタがある位置の数値をASCII code と見なして、その文字を出力する。
* 命令６「,」:標準入力から１文字読込、その文字のASCII code をポインタ位置に書込。
* 命令７「[」:ポインタの位置の数値が０以外なら何もしない。０なら、対応する「]」まで命令を読み飛ばし、「]」の次の命令から実行する。
* 命令８「]」:ポインタ位置の数値が０なら何もしない。０以外なら、対応する「[」まで戻り、「[」の次の命令から実行する。

の８つの定義。
これ以外の文字を使った場合無視する
そのため、自由にインデントを入れることができる。

####命令７と命令８について

* brainf*ckでは「[」と「]」が分岐いわゆるifなど、と繰り返しいわゆるwhileなどを兼ねている。
* 「[」と「]」はネストして使用可能、つまり二重や三重のループ処理も可能ということ
* ただし、「[」と「]」は必ず１対１に対応すること。

```ruby
+++[---]>---]
```

のように「]」が「[」より多かったり

```ruby
--[++[++[---]>
```

のように「[」が「]」より多いプログラムは認められない。

####移植性のための注意事項

* brainf*ckはシンプルである。
* なのでコンパイラやインタプリタなどの処理系が多く作られている。
* しかし,brainf*ckには厳密に決められた言語仕様が存在しないので、処理系によって細部の動作が微妙に異なる。
* （例）
* ポインタが一番左に位置するとき「<」命令を使用時、起こる挙動は不確定。
* ポインタ位置の数値が２５５時「+」命令を使用した時、起こる挙動は不確定。
* ポインタ位置の数値が０時「-」命令を使用した時、起こる挙動は不確定。
* などなど。

トークンについて
initializeでソースコードsrcをcharsで文字列に分割している。
Brainf*ckには「[」と「]」というジャンプ命令が存在するため、ソースコードにランダムにアクセスする必要があるゆえ。  

文字単位に分割したソースコードは、@tokensという変数に保存している。  
トークンとはソースコードを処理系が扱いやすいように分割したものをいう。  
今回のbrainf*ckは命令がたったの８つでかつ、１文字の命令のみなのでトークンに分割するには単に一文字で区切れば良い。  

##「+」「-」の実装について
まずは、インタプリタの状態を示す三つの変数が必要。  
####変数
* tape = []  
テープを表現する配列。テープの長さはrubyを使うため、メモリが許す限りの長い配列を可能にする。  
テープは全て0に初期化する必要があるが、半永久的な長さの配列を0で初期化はしない。  
つまり、テープの各位置のfirstアクセス時に0で初期化。
* pc = 0  
brainf*ckプログラムの最初から何番目の命令を実行しているかを示す変数。  
初期値は0  
基本は命令を一つ読むごとに１加算するが、「[」「]」を使った場合は値が大きく変化することもある。  
* cur = 0  
ポインタが現在どの要素を指しているかを示す変数  
初期値は0  
currentの略

###tape[cur]初期化の実装

```ruby
tape[cur] ||= 0
```
のコードで初期化している。  
"||="　は初期化されていないかもしれない変数を使うときのイデオム。 
"x|| = y"は"x = x||y"の略した記法である。
つまり、

```ruby
tape[cur] = tape[cur] || 0
```
tape[cur]が nill か false　なら,  
tape[cur]には0が代入される。  
tape[cur]にnilでもfalseでもない値が入っていた場合は、

```ruby
tape[cur] = tape[cur]
```
と同じになる。  
なので、tape[cur]の値は不変である。  
##「>」「<」の実装について
ポインタを左右に動かす「>」「<」は、変数curを1加算したり、１減算するだけなので、実装は簡単。  
注意点を一つ挙げるとしたら、ポインタがテープの左端にあるときに「<」を実行した場合、エラーにすべきとする。  

rubyでエラー報告を行うには、例外を使うのが簡単。

```ruby
raise "開始地点より左には移動できません"
```
このように、エラーメッセージを引数に取りKernel#raiseメソッドをcallすれば良い。  
(環境によっては、文字コードに応じて-Kオプションが必要)

ProgramErrorという新たな例外処理の定義

```ruby
class ProgramError < StandardError
end

raise ProgramError, "プログラムが間違っているようです"
```
により定義できる。  
またStandardErrorをcallし親クラスに選んだわけは、rescueでキャッチできるのがこのクラスのみであるから。  

参照方法  
例外ProgramErrorは「class Brainf_ck」の中で定義しているので、Brainf_ckを使う側からは、  
「Brainf_ck::ProgramError」という名前で参照できる。  

##「.」「,」の実装  
入出力を行う命令、「.」「,」の実装は以下  

```ruby
when "."
  n = (tape[cur] || 0)
  print n.chr
when ","
  tape[cur] = $stdin.getc.org
end
```

##「[」「]」の実装
最後に、条件によってジャンプを行う命令の実装をする。  
「[」命令は、ポインタ位置の数値が０ならば、対応する「]」までジャンプする。
また、「]」命令は、ポインタの位置の数値が０以外なら「[」までジャンプする。  

###対応するの条件について  
この条件は少し厄介である。  
というのも、例えば

```ruby
[+++[---]---]+++
```
というループが二重になっているプログラムがあるとして、「対応する」という条件なので、  
二つ目の「]」にジャンプしなければならない  
今回は、簡単なプログラムの実行開始前にあらかじめ全てのジャンプ位置を解析しておくことであるので、それを適用。  

例えば、上のプログラムに対し、ハッシュを用意する。  
(ジャンプ命令の解析)
```ruby
[++ [ --- ] --- ]+ + +
0123456789101112131415

@jumps = {
  0 => 12,
  12 => 0,
  4 => 8,
  8 => 4
  }
```
つまり、@tokensのpc番目の命令が「[」だった時、@jumps[pc]を見れば対応する「]」の位置がわかるようにする。  
もちろん、逆に「]」の位置から「[」がわかることも必要だ。  
もしもこのような変数を用意できれば、「[」命令と「]」命令は以下のように簡単に実装できる。

```ruby
def run
  #(略)
  
  while pc < @tokens.size
    case @tokens[pc]
    when "+"
      
      #(略)
      
    when "["
      if tape[cur] == 0
       pc = @jumps[pc]
      end
    when "]"
      if tape[cur] != 0
      pc = @jumps[pc]
    end
  end
  pc += 1
  end
  end
```
「[」命令を見つけた時は、もしもポインタ位置の値(@tape[cur])が0なら対応する「]」のある位置（@jumps[pc]）に飛ぶ。  
実に単純だ。

##ジャンプ命令を解析するメソッドについて。

```ruby
def analyse_jumps(tokens)
  jumps = {}  
  starts = []
  
  tokens.each_with_index do |c, i|
    if c == "["
      starts.push(i)
    elsif c == "]"
      raise ProgramError, "「]」が多すぎます" if starts.empty?
      from = starts.pop
      to = i
      
      jumps[from] = to
      jumps[to] = from
    end
  end
  raise ProgramError, "「[」が多すぎます" unless stats.empty?
  
  jumps
end
```

each_with_indexについて  
```
each_with_index (Enumerable) 編集   履歴
標準クラス・モジュール > Enumerable > each_with_index

enum.each_with_index {|item, idx| block }
each_with_indexメソッドは、要素の数だけブロックを繰り返し実行します。繰り返しごとにブロック引数itemには各要素が入り、idxには0、1、2、...と番号が入ります。

戻り値はレシーバ自身です。Ruby 1.8.7、1.9ではブロックを省略したときはEnumeratorオブジェクトを返します。

animals = ["dog", "cat", "mouse"]
animals.each_with_index {|anim, i| puts "#{i+1}. #{anim}" }
1. dog
2. cat
3. mouse
```
##解析コードのアルゴリズムについて  

* 1、まず、jumpsという名前の空のハッシュと、startsという名前の空の配列を用意する。
* 2、tokensを１つ見ていく。ここでは命令そのものだけでなく、何番目なのかも知りたいので、Enumerable#each_with_indexを使用。
* 3、「[」を見つけたら、その位置（i）をstartsの一番最後に追加する（push）。
* 4、「]」を見つけたら、直前に見つけた「[」の位置をstartsから取り除き(starts.pop)、今見つけた「[」が出てきていない（starts.empty?）時はBrainf*ckプログラムがおかしいのので、ProgramErrorを投げる。    
popメソッドは、配列の末尾の要素を削除し、その要素を返します。レシーバ自身を変更するメソッドです。配列が空のときはnilを返します。
* 5、これを最後の命令まで繰り返す。最後まで見終わった後startsが空になっていなければ、「[」が多すぎるので、ProgramErrorをcallする。
* 6、jumpsを返り値として返す。  

後は、initializeでこのメソッドをcallすればBrainf*ckインタプリタがCompletion。  
なお、analyzeメソッドはprivateメッソドにすること。



####ASCIIコード表
[Link](http://www9.plala.or.jp/sgwr-t/c_sub/ascii.html)


#### © copy write by kazuya yuda all right reserve.



